<!DOCTYPE html>
<meta charset="utf-8">
<title>Form Engine — sections, array, showIf, compute, lookup</title>
<style>
  :root { --b:#d9d9e3; --t:#222; --mut:#666; }
  *{box-sizing:border-box}

  /* render-only if URL has #f=... */
  body.render-only header, 
  body.render-only textarea { display:none }
  body.render-only main { padding:.75rem; height:auto }
  body.render-only #out { flex:1; width:100% }

  body{margin:0;font:14px system-ui,Segoe UI,Roboto,Arial;color:var(--t)}
  header{display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;border-bottom:1px solid var(--b)}
  header button{padding:.35rem .6rem;border:1px solid var(--b);background:#fff;border-radius:6px;cursor:pointer}
  header .hint{color:var(--mut);font-size:12px}
  main{display:flex;gap:.75rem;padding:.75rem;height:calc(100vh - 52px)}
  textarea{flex:1;resize:none;border:1px solid var(--b);border-radius:8px;padding:.6rem;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  #out{flex:1;border:1px solid var(--b);border-radius:8px;padding:.9rem;overflow:auto}
  h2{margin:.25rem 0 .5rem}
  h3{margin:.9rem 0 .35rem;font-size:1rem}
  .row{margin:.5rem 0}
  label{display:block;margin:0 0 .2rem}
  .mut{color:var(--mut);font-size:12px}
  .box{border:1px dashed var(--b);border-radius:8px;padding:.6rem;margin:.75rem 0}
  .soft{border:1px solid #eee;border-radius:8px;padding:.6rem;margin:.5rem 0;background:#fafafa}
  pre{margin:.35rem 0;background:#fafafa;border:1px solid #eee;border-radius:8px;padding:.6rem;white-space:pre-wrap}
  .netok{color:#0a7a0a}.neterr{color:#b00020}
  .inline{display:inline;margin-left:.35rem}
  .right{float:right}
  .btn{padding:.25rem .5rem;border:1px solid var(--b);border-radius:6px;background:#fff;cursor:pointer}
  .mini{font-size:12px;padding:.15rem .4rem}
</style>

<header>
  <button id="apply">Apply</button>
  <button id="format">Format</button>
  <button id="reset">Reset</button>
  <button id="copy">Copy JSON</button>
  <button id="share">Share Link</button>
  <button id="export">Export HTML</button>
  <span class="hint">Edit JSON → Apply. Autosaves to localStorage.</span>
</header>

<main>
  <textarea id="dsl" spellcheck="false"></textarea>
  <div id="out"></div>
</main>

<script>
/* ---------- Storage & Defaults ---------- */
const LS_KEY = "form_engine_v3";
const $ = s => document.querySelector(s);

/*
 DEMO: Bank-client admin flavored JSON
 - sections (CRM-ish)
 - showIf
 - array (repeaters)
 - compute
 - lookup (autocomplete with fetch)
*/
const DEFAULT_SPEC = {
  "title": "Bank Client Admin — Demo",
  "description": "Sections, repeaters, showIf, compute, and a live lookup. Ready for high-design Runner or internal Admin.",
  "send": {
    "url": "https://httpbin.org/post",
    "method": "POST",
    "headers": { "Content-Type": "application/json" }
  },
  "sections": [
    {
      "title": "Identity",
      "fields": [
        { "key":"client_type","label":"Client Type","type":"radio","options":["Person","Company"],"value":"Person","required":true },
        { "key":"first_name","label":"First name","type":"text","showIf":{"key":"client_type","op":"=","value":"Person"},"required":true },
        { "key":"last_name","label":"Last name","type":"text","showIf":{"key":"client_type","op":"=","value":"Person"},"required":true },
        { "key":"company_name","label":"Company name","type":"text","showIf":{"key":"client_type","op":"=","value":"Company"} },
        { "key":"email","label":"Email","type":"email","placeholder":"client@example.com" },
        { "key":"phone","label":"Phone","type":"tel","placeholder":"+49 ..." }
      ]
    },
    {
      "title": "Addresses",
      "fields": [
        {
          "key":"addresses","label":"Addresses","type":"array",
          "value":[{ "type":"Home","street":"Musterstraße 1","zip":"10115","city":"Berlin","country":"DE" }],
          "of":{"fields":[
            { "key":"type","label":"Type","type":"select","options":["Home","Billing","Business"],"value":"Home" },
            { "key":"street","label":"Street","type":"text","required":true },
            { "key":"zip","label":"ZIP","type":"text","placeholder":"e.g. 10115" },
            { "key":"city","label":"City","type":"text" },
            { "key":"country","label":"Country","type":"text","value":"DE" }
          ]}
        }
      ]
    },
    {
      "title": "Products",
      "fields": [
        { "key":"seats","label":"Seat count","type":"number","value":3,"required":true, "min":1 },
        { "key":"rate","label":"Monthly rate (€ / seat)","type":"number","value":29,"required":true, "min":0 },
        { "key":"discount_pct","label":"Discount (%)","type":"number","value":0 },
        { "key":"gross","label":"Gross (€/mo)","type":"text","compute":"seats * rate" },
        { "key":"net","label":"Net after discount (€/mo)","type":"text","compute":"(seats * rate) * (1 - discount_pct/100)" }
      ]
    },
    {
      "title": "KYC",
      "fields": [
        { "key":"is_vat_registered","label":"VAT registered?","type":"radio","options":["Yes","No"],"value":"No" },
        { "key":"vat_id","label":"VAT ID","type":"text","placeholder":"DE...","showIf":{"key":"is_vat_registered","op":"=","value":"Yes"} },
        {
          "key":"branch","label":"Assign Branch","type":"lookup",
          "placeholder":"Type to search branches…",
          "fetchOptions": {
            "url":"https://jsonplaceholder.typicode.com/users",
            "q":"q",          
            "labelKey":"name",            /* what user sees */
            "valueKey":"id",              /* what we store */
            "minChars": 2,
            "debounceMs": 200
          }
        },
        { "key":"tos","label":"I confirm data is accurate","type":"checkbox","required":true }
      ]
    }
  ]
};

/* ---------- Persistence / editor ---------- */
function loadSpec() {
  const raw = localStorage.getItem(LS_KEY);
  $("#dsl").value = raw ? raw : JSON.stringify(DEFAULT_SPEC, null, 2);
}
function saveSpec() { localStorage.setItem(LS_KEY, $("#dsl").value); }
function formatSpec() {
  try { $("#dsl").value = JSON.stringify(JSON.parse($("#dsl").value), null, 2); saveSpec(); }
  catch (e) { alert("Invalid JSON: " + e.message); }
}
function resetSpec() {
  if (!confirm("Reset to default?")) return;
  $("#dsl").value = JSON.stringify(DEFAULT_SPEC, null, 2);
  saveSpec(); render();
}
function copySpec() { navigator.clipboard.writeText($("#dsl").value); }

/* ---------- URL-safe Base64 (Unicode) ---------- */
function b64uEncode(str){
  const bytes = new TextEncoder().encode(str);
  let bin=""; bytes.forEach(b=>bin+=String.fromCharCode(b));
  return btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
}
function b64uDecode(s){
  s=s.replace(/-/g,"+").replace(/_/g,"/"); s+="===".slice((s.length+3)%4);
  const bin=atob(s), bytes=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
  return new TextDecoder().decode(bytes);
}

/* ---------- Hash IO + modes ---------- */
function writeHashFromEditor(){
  try{
    const pretty = JSON.stringify(JSON.parse($("#dsl").value));
    const enc = b64uEncode(pretty);
    location.hash = "f=" + enc;
    navigator.clipboard.writeText(location.href);
    alert("Shareable link copied to clipboard.");
  }catch(e){ alert("Invalid JSON: "+e.message); }
}
function readHashToEditor(){
  if (!location.hash.startsWith("#f=")) return false;
  try{
    const enc = location.hash.slice(3);
    const json = b64uDecode(enc);
    JSON.parse(json);
    $("#dsl").value = JSON.stringify(JSON.parse(json), null, 2);
    saveSpec(); render();
    return true;
  }catch{ console.warn("Bad hash payload."); }
  return false;
}
function setRenderModeFromHash(){
  const renderOnly = location.hash.startsWith("#f=");
  document.body.classList.toggle("render-only", renderOnly);
}

/* ---------- Tiny utils ---------- */
function el(tag, props={}, ...kids){
  const node = document.createElement(tag);
  Object.entries(props).forEach(([k,v])=>{
    if (k === "class") node.className = v;
    else if (k === "for") node.htmlFor = v;
    else if (k === "style") node.style.cssText = v;
    else if (k === "list") node.setAttribute("list", v);      // <-- fix: force attribute
    else if (k in node) node[k] = v;
    else node.setAttribute(k, v);
  });
  kids.forEach(k => node.appendChild(typeof k === "string" ? document.createTextNode(k) : k));
  return node;
}
const isArr = Array.isArray;

/* ---------- Field iteration across sections or flat ---------- */
function eachField(spec, fn){
  if (isArr(spec.fields)) { spec.fields.forEach(fn); return; }
  if (isArr(spec.sections)) { spec.sections.forEach(sec => (sec.fields||[]).forEach(fn)); }
}
function fieldList(spec){
  if (isArr(spec.fields)) return spec.fields;
  if (isArr(spec.sections)) return spec.sections.flatMap(s=>s.fields||[]);
  return [];
}

/* ---------- Conditional logic ---------- */
function evalCond(cond, values){
  if (!cond) return true;
  const a = values[cond.key];
  const b = cond.value;
  switch (cond.op) {
    case "=":  return a == b;
    case "!=": return a != b;
    case ">":  return (+a) > (+b);
    case ">=": return (+a) >= (+b);
    case "<":  return (+a) < (+b);
    case "<=": return (+a) <= (+b);
    case "includes": return Array.isArray(a) ? a.includes(b) : (a||"").includes?.(b);
    default: return !!a;
  }
}

/* ---------- Compute ---------- */
function safeNumber(x){ const n=+x; return isFinite(n)?n:0; }
function evalCompute(expr, values){
  // replace identifiers with numeric values; allow + - * / ( ) . and spaces
  const replaced = expr.replace(/[A-Za-z_][A-Za-z0-9_]*/g, m => String(safeNumber(values[m])));
  try { return String(Function("return ("+replaced+")")()); } catch { return ""; }
}

/* ---------- Lookup (datalist + fetch) ---------- */
function buildLookup(id, name, f, preset){
  const row = el("div",{class:"row"});
  row.appendChild(el("label",{"for":id}, (f.label||f.key) + (f.required?" *":"")));

  const listId = id+"_list";
  const text = el("input",{type:"text", id, list:listId, placeholder:f.placeholder||"", required:!!f.required});
  const hidden = el("input",{type:"hidden", id:id+"_value", name:name});
  const list = el("datalist",{id:listId});
  row.appendChild(text); row.appendChild(list); row.appendChild(hidden);

  if (preset!=null) hidden.value = preset;

  const fo = f.fetchOptions||{};
  const url = fo.url||"";
  const qParam = fo.q || "q";
  const labelKey = fo.labelKey || "label";
  const valueKey = fo.valueKey || "value";
  const minChars = fo.minChars ?? 2;
  const debounceMs = fo.debounceMs ?? 200;

  let timer = null;
  let cache = new Map(); // label -> value

  async function doFetch(q){
    if (!url) return;
    try{
      const u = new URL(url, location.origin);
      u.searchParams.set(qParam, q);
      const res = await fetch(u.toString());
      const data = await res.json();
      list.innerHTML = "";
      cache.clear();
      (data||[]).forEach(item=>{
        const lbl = String(item[labelKey]);
        const val = item[valueKey];
        cache.set(lbl, val);
        list.appendChild(el("option",{value:lbl}));
      });
    }catch(e){ /* no-op for demo */ }
  }
  function schedule(q){ clearTimeout(timer); timer = setTimeout(()=>doFetch(q), debounceMs); }

  function syncHiddenFromLabel(){
    const lbl = text.value;
    // Store mapped value if we know it, otherwise store the label the user typed
    hidden.value = cache.has(lbl) ? cache.get(lbl) : lbl;
  }

  text.addEventListener("input", e=>{
    const q = e.target.value || "";
    if (q.length >= minChars) schedule(q);
    // don't set hidden yet; wait for change/blur or exact match
  });
  text.addEventListener("change", syncHiddenFromLabel);
  text.addEventListener("blur", syncHiddenFromLabel);

  return row;
}

/* ---------- Simple + Array builders ---------- */
function buildSimpleField(id, name, f, preset){
  const row = el("div", {class:"row"});
  const labelText = f.label || f.key;
  const commonAttrs = a=>{
    if (f.pattern) a.pattern = f.pattern;
    if (f.min!=null) a.min = f.min;
    if (f.max!=null) a.max = f.max;
    if (f.minLength!=null) a.minLength = f.minLength;
    if (f.maxLength!=null) a.maxLength = f.maxLength;
    return a;
  };

  if (f.type === "lookup") return buildLookup(id, name, f, f.value);

  if (f.type !== "checkbox" && f.type !== "radio" && labelText) {
    row.appendChild(el("label", {"for":id}, labelText + (f.required ? " *" : "")));
  }

  let fieldEl;

  if (f.type === "textarea") {
    fieldEl = el("textarea", commonAttrs({id, name, placeholder:f.placeholder||"", required:!!f.required}));
    if (preset != null) fieldEl.value = preset;

  } else if (f.type === "select") {
    fieldEl = el("select", commonAttrs({id, name, required:!!f.required}));
    (f.options||[]).forEach(opt=>{
      const o = el("option", {value:String(opt)}, String(opt));
      if (preset === opt) o.selected = true;
      fieldEl.appendChild(o);
    });

  } else if (f.type === "radio") {
    fieldEl = el("div");
    if (labelText) row.appendChild(el("label", {}, labelText + (f.required ? " *" : "")));
    (f.options||[]).forEach((opt, idx)=>{
      const rid = id + "_" + String(opt).replace(/\W+/g,"_");
      const r = el("input", {type:"radio", id:rid, name, value:String(opt)});
      if (preset === opt) r.checked = true;
      if (f.required && idx===0) r.required = true;
      const lab = el("label", {"for":rid, style:"display:inline-block;margin-right:.75rem;vertical-align:middle"}, String(opt));
      fieldEl.appendChild(r); fieldEl.appendChild(lab);
    });

  } else if (f.type === "checkbox") {
    fieldEl = el("input", {type:"checkbox", id, name});
    if (preset) fieldEl.checked = true;
    const inline = el("label", {"for":id, class:"inline"}, labelText + (f.required ? " *" : ""));
    row.appendChild(fieldEl); row.appendChild(inline);
    return row;

  } else if (f.compute) {
    fieldEl = el("input", {type:"text", id, name, readOnly:true});

  } else {
    fieldEl = el("input", commonAttrs({type:f.type||"text", id, name, placeholder:f.placeholder||"", required:!!f.required}));
    if (preset != null) fieldEl.value = preset;
  }

  row.appendChild(fieldEl);
  return row;
}

function buildArrayField(form, f){
  const row = el("div", {class:"row"});
  row.appendChild(el("label", {}, (f.label || f.key) + (f.required ? " *" : "")));
  const cont = el("div", {class:"soft", "data-arr": f.key});
  row.appendChild(cont);

  const items = isArr(f.value) ? JSON.parse(JSON.stringify(f.value)) : [{}];

  function renderItems(){
    cont.innerHTML = "";
    items.forEach((itm, idx)=>{
      const gi = el("div", {class:"soft", "data-idx": idx});
      (f.of?.fields||[]).forEach(sf=>{
        const sid = `${f.key}__${idx}__${sf.key}`;
        const sname = sid;
        const preset = itm[sf.key];
        gi.appendChild(buildSimpleField(sid, sname, sf, preset));
      });
      const rm = el("button", {type:"button", class:"btn mini right", onclick:()=>{ items.splice(idx,1); renderItems(); }}, "Remove");
      gi.appendChild(rm);
      cont.appendChild(gi);
    });
    const add = el("button", {type:"button", class:"btn mini", onclick:()=>{ items.push({}); renderItems(); }}, "+ Add");
    cont.appendChild(add);
  }
  renderItems();

  row._collectArray = () => {
    const arr=[];
    cont.querySelectorAll('[data-idx]').forEach((gi,i)=>{
      const obj={};
      (f.of?.fields||[]).forEach(sf=>{
        const id = `${f.key}__${i}__${sf.key}`;
        if (sf.type==="radio") {
          const ch = gi.querySelector(`input[name="${id}"]:checked`);
          obj[sf.key] = ch?ch.value:null;
        } else if (sf.type==="checkbox") {
          const elx = gi.querySelector(`#${CSS.escape(id)}`);
          obj[sf.key] = !!(elx && elx.checked);
        } else {
          const elx = gi.querySelector(`#${CSS.escape(id)}`);
          obj[sf.key] = elx?elx.value:null;
        }
      });
      arr.push(obj);
    });
    return arr;
  };

  return row;
}

/* ---------- Render one field ---------- */
function buildField(form, f, trackers){
  const key = f.key;
  const id = key;
  const name = key;

  let row;
  if (f.type === "array")       row = buildArrayField(form, f);
  else                          row = buildSimpleField(id, name, f, f.value);

  // track showIf + compute
  if (f.showIf) trackers.conds.push({el: row, cond: f.showIf});
  if (f.compute) {
    const inputEl = row.querySelector("#"+CSS.escape(id));
    trackers.computes.push({el: inputEl, expr: f.compute});
  }

  row.dataset.fieldKey = key;
  row.dataset.fieldType = f.type || (f.compute ? "compute" : "text");
  return row;
}

/* ---------- Read current flat values (top-level only) ---------- */
function readFlatValues(spec, form){
  const values = {};
  fieldList(spec).forEach(f=>{
    if (f.type === "array") return;
    if (f.type === "lookup") {
      const i = form.querySelector(`#${CSS.escape(f.key)}_value`);
      values[f.key] = i ? i.value : null;
    } else if (f.type === "radio") {
      const checked = form.querySelector(`input[name="${CSS.escape(f.key)}"]:checked`);
      values[f.key] = checked ? checked.value : null;
    } else if (f.type === "checkbox") {
      const i = form.querySelector(`#${CSS.escape(f.key)}`);
      values[f.key] = !!(i && i.checked);
    } else {
      const i = form.querySelector(`#${CSS.escape(f.key)}`);
      values[f.key] = i ? i.value : null;
    }
  });
  return values;
}

/* ---------- Visibility + compute updater ---------- */
function updateVisibilityAndCompute(spec, form, trackers){
  const values = readFlatValues(spec, form);

  // apply showIf
  trackers.conds.forEach(c=>{
    const show = evalCond(c.cond, values);
    c.el.style.display = show ? "" : "none";
    c.el.querySelectorAll("input,select,textarea").forEach(n=>{ n.disabled = !show; if(!show) n.required=false; });
  });

  // computes
  trackers.computes.forEach(co=>{
    const v = evalCompute(co.expr, values);
    if (co.el) co.el.value = v;
  });
}

/* ---------- Collect data (respects visibility) ---------- */
function collectData(spec, form){
  const data = {};
  fieldList(spec).forEach(f=>{
    const row = form.querySelector(`[data-field-key="${CSS.escape(f.key)}"]`);
    const visible = !row || row.style.display !== "none";

    if (!visible) return;

    if (f.type === "array") {
      if (row._collectArray) data[f.key] = row._collectArray();
      return;
    }
    if (f.type === "lookup") {
      const i = form.querySelector(`#${CSS.escape(f.key)}_value`);
      data[f.key] = i ? i.value : null;
      return;
    }
    if (f.type === "radio") {
      const checked = form.querySelector(`input[name="${CSS.escape(f.key)}"]:checked`);
      data[f.key] = checked ? checked.value : null;
    } else if (f.type === "checkbox") {
      const i = form.querySelector(`#${CSS.escape(f.key)}`);
      data[f.key] = !!(i && i.checked);
    } else {
      const i = form.querySelector(`#${CSS.escape(f.key)}`);
      data[f.key] = i ? i.value : null;
    }
  });
  return data;
}

/* ---------- Networking ---------- */
async function maybeSend(spec, payload, ui) {
  const cfg = spec.send || {};
  const url = (cfg.url||"").trim();
  if (!url) { ui.net.textContent = "Not sending (no send.url)."; ui.net.className="mut"; return; }

  const method = (cfg.method||"POST").toUpperCase();
  const headers = Object.assign({"Content-Type":"application/json"}, cfg.headers||{});
  ui.net.textContent = "Sending…"; ui.net.className="mut";

  try {
    const res = await fetch(url, {method, headers, body: JSON.stringify(payload)});
    const text = await res.text();
    ui.net.textContent = `HTTP ${res.status} ${res.ok ? "OK" : res.statusText}`;
    ui.net.className = res.ok ? "netok" : "neterr";
    ui.resp.textContent = text || "(empty response body)";
  } catch (err) {
    ui.net.textContent = "Network error: " + err.message;
    ui.net.className = "neterr";
  }
}

/* ---------- Render ---------- */
function parseSpec() {
  try { return [JSON.parse($("#dsl").value), null]; }
  catch (e) { return [null, e]; }
}

function render(){
  saveSpec();

  const [spec, err] = parseSpec();
  if (err) { $("#out").innerHTML = "<b>JSON error:</b> " + err.message; return; }

  const root = el("div");

  root.appendChild(el("h2", {}, spec.title || "Form"));
  if (spec.description) root.appendChild(el("div", {class:"mut"}, spec.description));

  const form = el("form", {action:"#", method:"POST"});
  const trackers = {conds:[], computes:[]};

  if (isArr(spec.sections)) {
    spec.sections.forEach(sec=>{
      if (sec.title) form.appendChild(el("h3", {}, sec.title));
      (sec.fields||[]).forEach(f=>{
        const row = buildField(form, f, trackers);
        form.appendChild(row);
      });
    });
  } else {
    (spec.fields||[]).forEach(f=>{
      const row = buildField(form, f, trackers);
      form.appendChild(row);
    });
  }

  // live updates (visibility + compute)
  form.addEventListener("input", ()=>updateVisibilityAndCompute(spec, form, trackers));
  form.addEventListener("change", ()=>updateVisibilityAndCompute(spec, form, trackers));
  setTimeout(()=>updateVisibilityAndCompute(spec, form, trackers)); // after DOM attach

  // submit
  form.appendChild(el("button", {type:"submit"}, "Submit"));

  // output
  const box = el("div", {class:"box"});
  const outHead = el("div", {}, el("b", {}, "Submission Preview "), el("span",{class:"mut"},"(no navigation)"));
  const outPre = el("pre", {}, "—");
  const net = el("div", {class:"mut", style:"margin-top:.25rem"}, "Not sent");
  const resp = el("pre", {}, "");
  box.appendChild(outHead);
  box.appendChild(outPre);
  box.appendChild(el("div",{class:"mut",style:"margin-top:.25rem"},"If send.url is set, we POST JSON below and show server response:"));
  box.appendChild(net);
  box.appendChild(resp);

  form.addEventListener("submit", async (e)=>{
    e.preventDefault();
    const values = collectData(spec, form);
    const payload = { data: values, meta: { formTitle: spec.title||"", timestamp: new Date().toISOString() } };
    outPre.textContent = JSON.stringify(payload, null, 2);
    await maybeSend(spec, payload, {net, resp});
  });

  root.appendChild(form);
  root.appendChild(box);

  $("#out").innerHTML = "";
  $("#out").appendChild(root);
}

/* ---------- Export (still here; optional) ---------- */
function exportHTML(){
  const currentDSL = (()=>{ try{return JSON.stringify(JSON.parse($("#dsl").value));}catch{ return JSON.stringify(DEFAULT_SPEC);} })();
  const seedScript = `<script>(function(){try{
    var k='${LS_KEY}'; if(!localStorage.getItem(k)){ localStorage.setItem(k, ${JSON.stringify(currentDSL)}); }
  }catch(e){}})();<\/script>`;
  const html = '<!DOCTYPE html>'+document.documentElement.outerHTML.replace('</body>', seedScript+'</body>');
  const blob = new Blob([html], {type:'text/html'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'form-engine.html';
  document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(a.href); a.remove();}, 600);
}

/* ---------- Wire up ---------- */
$("#apply").onclick = render;
$("#format").onclick = formatSpec;
$("#reset").onclick = resetSpec;
$("#copy").onclick = copySpec;
$("#dsl").addEventListener("input", saveSpec);
$("#share").onclick = writeHashFromEditor;
$("#export").onclick = exportHTML;
window.addEventListener("hashchange", ()=>{ readHashToEditor(); setRenderModeFromHash(); });

loadSpec();
readHashToEditor();
setRenderModeFromHash();
render();
</script>
